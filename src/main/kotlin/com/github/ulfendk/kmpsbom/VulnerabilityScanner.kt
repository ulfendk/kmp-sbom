package com.github.ulfendk.kmpsbom

import com.google.gson.Gson
import com.google.gson.JsonArray
import com.google.gson.JsonObject
import okhttp3.Credentials
import okhttp3.MediaType.Companion.toMediaType
import okhttp3.OkHttpClient
import okhttp3.Request
import okhttp3.RequestBody.Companion.toRequestBody
import org.cyclonedx.model.Bom
import org.cyclonedx.model.Component
import org.cyclonedx.model.vulnerability.Vulnerability
import org.gradle.api.logging.Logger
import java.util.concurrent.TimeUnit

/**
 * Scans dependencies for known vulnerabilities using OSS Index
 */
class VulnerabilityScanner(private val logger: Logger) {
    
    private val gson = Gson()
    private val ossIndexUrl = "https://ossindex.sonatype.org/api/v3/component-report"
    
    // Optional authentication credentials from environment variables
    private val ossIndexUsername = System.getenv("OSSINDEX_USERNAME")
    private val ossIndexToken = System.getenv("OSSINDEX_TOKEN")
    
    fun scan(components: List<Component>, bom: Bom) {
        if (components.isEmpty()) {
            logger.info("No components to scan for vulnerabilities")
            return
        }
        
        logger.lifecycle("Scanning ${components.size} components for vulnerabilities using OSS Index...")
        
        // Create HTTP client only when needed
        val client = OkHttpClient.Builder()
            .connectTimeout(30, TimeUnit.SECONDS)
            .readTimeout(30, TimeUnit.SECONDS)
            .build()
        
        try {
            val vulnerabilities = mutableListOf<Vulnerability>()
            
            // Process components in batches of 128 (OSS Index limit)
            components.chunked(128).forEach { batch ->
                val batchVulnerabilities = scanBatch(client, batch)
                vulnerabilities.addAll(batchVulnerabilities)
            }
            
            if (vulnerabilities.isNotEmpty()) {
                bom.vulnerabilities = vulnerabilities
                logger.lifecycle("Found ${vulnerabilities.size} vulnerabilities across ${components.size} components")
            } else {
                logger.lifecycle("No vulnerabilities found in ${components.size} components")
            }
        } catch (e: Exception) {
            logger.warn("Vulnerability scanning failed: ${e.message}")
            logger.debug("Vulnerability scanning error", e)
        } finally {
            // Clean up client resources
            client.dispatcher.executorService.shutdown()
            client.connectionPool.evictAll()
        }
    }
    
    private fun scanBatch(client: OkHttpClient, components: List<Component>): List<Vulnerability> {
        val vulnerabilities = mutableListOf<Vulnerability>()
        
        try {
            // Filter out components without valid PURL (required by OSS Index)
            val validComponents = components.filter { component ->
                component.purl != null && component.purl.startsWith("pkg:maven/")
            }
            
            if (validComponents.isEmpty()) {
                logger.debug("No valid Maven components to scan in this batch")
                return emptyList()
            }
            
            logger.debug("Scanning ${validComponents.size} components with OSS Index")
            
            // Query OSS Index for the entire batch
            val batchVulns = queryOssIndex(client, validComponents)
            vulnerabilities.addAll(batchVulns)
            
        } catch (e: Exception) {
            logger.warn("Failed to scan batch: ${e.message}")
            logger.debug("Batch scan error", e)
        }
        
        return vulnerabilities
    }
    
    /**
     * Query OSS Index API for vulnerability information
     */
    private fun queryOssIndex(client: OkHttpClient, components: List<Component>): List<Vulnerability> {
        val vulnerabilities = mutableListOf<Vulnerability>()
        
        // Build request body with component PURLs
        val coordinates = JsonArray()
        components.forEach { component ->
            component.purl?.let { coordinates.add(it) }
        }
        
        val requestBody = gson.toJson(JsonObject().apply {
            add("coordinates", coordinates)
        })
        
        logger.debug("Querying OSS Index for ${coordinates.size()} components")
        
        // Build request with optional authentication
        val requestBuilder = Request.Builder()
            .url(ossIndexUrl)
            .post(requestBody.toRequestBody("application/json".toMediaType()))
            .addHeader("Content-Type", "application/json")
            .addHeader("User-Agent", "kmp-sbom-gradle-plugin")
        
        // Add authentication if credentials are available
        if (!ossIndexUsername.isNullOrBlank() && !ossIndexToken.isNullOrBlank()) {
            val credentials = Credentials.basic(ossIndexUsername, ossIndexToken)
            requestBuilder.addHeader("Authorization", credentials)
            logger.debug("Using authenticated OSS Index request")
        } else {
            logger.debug("Using unauthenticated OSS Index request (rate limited)")
        }
        
        val request = requestBuilder.build()
        
        client.newCall(request).execute().use { response ->
            if (!response.isSuccessful) {
                logger.warn("OSS Index request failed: ${response.code} ${response.message}")
                return emptyList()
            }
            
            val responseBody = response.body?.string() ?: return emptyList()
            val jsonArray = gson.fromJson(responseBody, JsonArray::class.java)
            
            // Parse response and create vulnerabilities
            jsonArray.forEach { element ->
                val componentData = element.asJsonObject
                val purl = componentData.get("coordinates")?.asString ?: return@forEach
                
                // Find matching component by PURL
                val component = components.find { it.purl == purl } ?: return@forEach
                
                // Check if component has vulnerabilities
                val vulns = componentData.get("vulnerabilities")?.asJsonArray
                if (vulns != null && vulns.size() > 0) {
                    logger.debug("Found ${vulns.size()} vulnerabilities for ${component.name}")
                    
                    vulns.forEach { vulnElement ->
                        val vulnData = vulnElement.asJsonObject
                        val vuln = parseOssIndexVulnerability(vulnData, component)
                        if (vuln != null) {
                            vulnerabilities.add(vuln)
                        }
                    }
                }
            }
        }
        
        return vulnerabilities
    }
    
    /**
     * Parse OSS Index vulnerability data into CycloneDX format
     */
    private fun parseOssIndexVulnerability(vulnData: JsonObject, component: Component): Vulnerability? {
        try {
            val cveId = vulnData.get("cve")?.asString
            val title = vulnData.get("title")?.asString ?: ""
            val description = vulnData.get("description")?.asString ?: ""
            val cvssScore = vulnData.get("cvssScore")?.asDouble
            val cvssVector = vulnData.get("cvssVector")?.asString
            val reference = vulnData.get("reference")?.asString
            
            val vulnerability = Vulnerability()
            
            // Set ID (prefer CVE ID, fall back to title)
            vulnerability.id = cveId ?: "OSSINDEX-${title.hashCode()}"
            
            // Set source
            vulnerability.source = Vulnerability.Source().apply {
                name = "OSS Index"
                url = reference
            }
            
            // Set description
            vulnerability.description = if (description.isNotBlank()) {
                description
            } else {
                title
            }
            
            // Set ratings with CVSS score
            if (cvssScore != null) {
                val rating = Vulnerability.Rating()
                rating.score = cvssScore
                rating.method = Vulnerability.Rating.Method.CVSSV3
                rating.vector = cvssVector
                
                // Map CVSS score to severity
                rating.severity = when {
                    cvssScore >= 9.0 -> Vulnerability.Rating.Severity.CRITICAL
                    cvssScore >= 7.0 -> Vulnerability.Rating.Severity.HIGH
                    cvssScore >= 4.0 -> Vulnerability.Rating.Severity.MEDIUM
                    cvssScore >= 0.1 -> Vulnerability.Rating.Severity.LOW
                    else -> Vulnerability.Rating.Severity.NONE
                }
                
                vulnerability.ratings = listOf(rating)
            }
            
            // Add affected component reference
            val affect = Vulnerability.Affect()
            affect.ref = component.bomRef
            vulnerability.affects = listOf(affect)
            
            return vulnerability
        } catch (e: Exception) {
            logger.warn("Failed to parse vulnerability: ${e.message}")
            return null
        }
    }
}
