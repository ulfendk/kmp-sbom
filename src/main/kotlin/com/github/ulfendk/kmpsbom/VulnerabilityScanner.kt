package com.github.ulfendk.kmpsbom

import com.google.gson.Gson
import com.google.gson.JsonArray
import com.google.gson.JsonObject
import okhttp3.Credentials
import okhttp3.MediaType.Companion.toMediaType
import okhttp3.OkHttpClient
import okhttp3.Request
import okhttp3.RequestBody.Companion.toRequestBody
import org.cyclonedx.model.Bom
import org.cyclonedx.model.Component
import org.cyclonedx.model.vulnerability.Vulnerability
import org.gradle.api.logging.Logger
import java.util.concurrent.TimeUnit

/**
 * Scans dependencies for known vulnerabilities using configured scanners
 */
class VulnerabilityScanner(
    private val logger: Logger,
    private val extension: KmpSbomExtension
) {
    
    private val gson = Gson()
    private val ossIndexUrl = "https://ossindex.sonatype.org/api/v3/component-report"
    private val githubGraphQLUrl = "https://api.github.com/graphql"
    
        // Get credentials from extension or environment variables
        // Validate tokens to prevent header injection
        val ossIndexUsername = (extension.ossIndexUsername ?: System.getenv("OSSINDEX_USERNAME"))?.trim()
        val ossIndexToken = (extension.ossIndexToken ?: System.getenv("OSSINDEX_TOKEN"))?.trim()?.takeIf { 
            it.none { c -> c.isISOControl() } 
        }
        val githubToken = (extension.githubToken ?: System.getenv("GITHUB_TOKEN"))?.trim()?.takeIf {
            it.none { c -> c.isISOControl() }
        }
    
    fun scan(components: List<Component>, bom: Bom) {
        if (components.isEmpty()) {
            logger.info("No components to scan for vulnerabilities")
            return
        }
        
        val scanners = determineScanners()
        if (scanners.isEmpty()) {
            logger.warn("No vulnerability scanners configured")
            return
        }
        
        logger.lifecycle("Scanning ${components.size} components for vulnerabilities using: ${scanners.joinToString(", ")}")
        
        // Create HTTP client only when needed
        val client = OkHttpClient.Builder()
            .connectTimeout(30, TimeUnit.SECONDS)
            .readTimeout(30, TimeUnit.SECONDS)
            .build()
        
        try {
            val allVulnerabilities = mutableListOf<Vulnerability>()
            
            // Run each configured scanner
            if (scanners.contains("ossindex")) {
                val ossIndexVulns = scanWithOssIndex(client, components)
                allVulnerabilities.addAll(ossIndexVulns)
            }
            
            if (scanners.contains("github")) {
                val githubVulns = scanWithGitHub(client, components)
                allVulnerabilities.addAll(githubVulns)
            }
            
            // Deduplicate vulnerabilities by ID
            val uniqueVulnerabilities = allVulnerabilities
                .groupBy { it.id }
                .mapValues { (_, vulns) -> vulns.first() }
                .values
                .toList()
            
            if (uniqueVulnerabilities.isNotEmpty()) {
                bom.vulnerabilities = uniqueVulnerabilities
                logger.lifecycle("Found ${uniqueVulnerabilities.size} unique vulnerabilities across ${components.size} components")
            } else {
                logger.lifecycle("No vulnerabilities found in ${components.size} components")
            }
        } catch (e: Exception) {
            logger.warn("Vulnerability scanning failed: ${e.message}")
            logger.debug("Vulnerability scanning error", e)
        } finally {
            // Clean up client resources
            client.dispatcher.executorService.shutdown()
            client.connectionPool.evictAll()
        }
    }
    
    /**
     * Determine which scanners to use based on configuration
     */
    private fun determineScanners(): List<String> {
        return when (extension.vulnerabilityScanners.lowercase()) {
            "ossindex" -> listOf("ossindex")
            "github" -> listOf("github")
            "all" -> listOf("ossindex", "github")
            else -> {
                logger.warn("Unknown scanner configuration: ${extension.vulnerabilityScanners}. Defaulting to 'all'")
                listOf("ossindex", "github")
            }
        }
    }
    
    /**
     * Scan components using OSS Index
     */
    private fun scanWithOssIndex(client: OkHttpClient, components: List<Component>): List<Vulnerability> {
        val vulnerabilities = mutableListOf<Vulnerability>()
        
        logger.debug("Scanning with OSS Index...")
        
        // Process components in batches of 128 (OSS Index limit)
        components.chunked(128).forEach { batch ->
            try {
                val batchVulns = scanBatchOssIndex(client, batch)
                vulnerabilities.addAll(batchVulns)
            } catch (e: Exception) {
                logger.warn("OSS Index batch scan failed: ${e.message}")
                logger.debug("OSS Index batch error", e)
            }
        }
        
        logger.info("OSS Index found ${vulnerabilities.size} vulnerabilities")
        return vulnerabilities
    }
    
    /**
     * Scan a batch of components with OSS Index
     */
    private fun scanBatchOssIndex(client: OkHttpClient, components: List<Component>): List<Vulnerability> {
        val vulnerabilities = mutableListOf<Vulnerability>()
        
        // Filter out components without valid PURL (required by OSS Index)
        val validComponents = components.filter { component ->
            component.purl != null && component.purl.startsWith("pkg:maven/")
        }
        
        if (validComponents.isEmpty()) {
            logger.debug("No valid Maven components to scan in this batch")
            return emptyList()
        }
        
        logger.debug("Scanning ${validComponents.size} components with OSS Index")
        
        // Query OSS Index for the entire batch
        val batchVulns = queryOssIndex(client, validComponents)
        vulnerabilities.addAll(batchVulns)
        
        return vulnerabilities
    }
    
    /**
     * Query OSS Index API for vulnerability information
     */
    private fun queryOssIndex(client: OkHttpClient, components: List<Component>): List<Vulnerability> {
        val vulnerabilities = mutableListOf<Vulnerability>()
        
        // Build request body with component PURLs
        val coordinates = JsonArray()
        components.forEach { component ->
            component.purl?.let { coordinates.add(it) }
        }
        
        val requestBody = gson.toJson(JsonObject().apply {
            add("coordinates", coordinates)
        })
        
        logger.debug("Querying OSS Index for ${coordinates.size()} components")
        
        // Build request with optional authentication
        val requestBuilder = Request.Builder()
            .url(ossIndexUrl)
            .post(requestBody.toRequestBody("application/json".toMediaType()))
            .addHeader("Content-Type", "application/json")
            .addHeader("User-Agent", "kmp-sbom-gradle-plugin")
        
        // Add authentication if credentials are available
        if (!ossIndexUsername.isNullOrBlank() && !ossIndexToken.isNullOrBlank()) {
            val credentials = Credentials.basic(ossIndexUsername, ossIndexToken)
            requestBuilder.addHeader("Authorization", credentials)
            logger.debug("Using authenticated OSS Index request")
        } else {
            logger.debug("Using unauthenticated OSS Index request (rate limited)")
        }
        
        val request = requestBuilder.build()
        
        client.newCall(request).execute().use { response ->
            if (!response.isSuccessful) {
                logger.warn("OSS Index request failed: ${response.code} ${response.message}")
                return emptyList()
            }
            
            val responseBody = response.body?.string() ?: return emptyList()
            val jsonArray = gson.fromJson(responseBody, JsonArray::class.java)
            
            // Parse response and create vulnerabilities
            jsonArray.forEach { element ->
                val componentData = element.asJsonObject
                val purl = componentData.get("coordinates")?.asString ?: return@forEach
                
                // Find matching component by PURL
                val component = components.find { it.purl == purl } ?: return@forEach
                
                // Check if component has vulnerabilities
                val vulns = componentData.get("vulnerabilities")?.asJsonArray
                if (vulns != null && vulns.size() > 0) {
                    logger.debug("Found ${vulns.size()} vulnerabilities for ${component.name}")
                    
                    vulns.forEach { vulnElement ->
                        val vulnData = vulnElement.asJsonObject
                        val vuln = parseOssIndexVulnerability(vulnData, component)
                        if (vuln != null) {
                            vulnerabilities.add(vuln)
                        }
                    }
                }
            }
        }
        
        return vulnerabilities
    }
    
    /**
     * Scan components using GitHub Security Advisory Database
     */
    private fun scanWithGitHub(client: OkHttpClient, components: List<Component>): List<Vulnerability> {
        val vulnerabilities = mutableListOf<Vulnerability>()
        
        if (githubToken.isNullOrBlank()) {
            logger.debug("GitHub token not configured, skipping GitHub scanner")
            return emptyList()
        }
        
        logger.debug("Scanning with GitHub Security Advisory Database...")
        
        // Filter Maven components
        val mavenComponents = components.filter { component ->
            component.purl != null && component.purl.startsWith("pkg:maven/")
        }
        
        if (mavenComponents.isEmpty()) {
            logger.debug("No Maven components to scan with GitHub")
            return emptyList()
        }
        
        // Process components individually (GitHub GraphQL doesn't support batch queries for this)
        mavenComponents.forEach { component ->
            try {
                val componentVulns = queryGitHub(client, component)
                vulnerabilities.addAll(componentVulns)
            } catch (e: Exception) {
                logger.debug("GitHub scan failed for ${component.name}: ${e.message}")
            }
        }
        
        logger.info("GitHub Security Advisory found ${vulnerabilities.size} vulnerabilities")
        return vulnerabilities
    }
    
    /**
     * Query GitHub Security Advisory Database using GraphQL
     */
    private fun queryGitHub(client: OkHttpClient, component: Component): List<Vulnerability> {
        val vulnerabilities = mutableListOf<Vulnerability>()
        
        // Escape special characters for GraphQL
        val packageName = "${component.group}:${component.name}".replace("\"", "\\\"").replace("\\", "\\\\")
        
        // Build GraphQL query to search for vulnerabilities
        val query = """
            {
              securityVulnerabilities(first: 10, ecosystem: MAVEN, package: "$packageName") {
                nodes {
                  advisory {
                    ghsaId
                    summary
                    description
                    severity
                    cvss {
                      score
                      vectorString
                    }
                    references {
                      url
                    }
                  }
                  vulnerableVersionRange
                }
              }
            }
        """.trimIndent()
        
        val requestBody = gson.toJson(mapOf("query" to query))
        
        val request = Request.Builder()
            .url(githubGraphQLUrl)
            .post(requestBody.toRequestBody("application/json".toMediaType()))
            .addHeader("Authorization", "Bearer $githubToken")
            .addHeader("Content-Type", "application/json")
            .build()
        
        client.newCall(request).execute().use { response ->
            if (!response.isSuccessful) {
                logger.debug("GitHub API request failed: ${response.code} ${response.message}")
                return emptyList()
            }
            
            val responseBody = response.body?.string() ?: return emptyList()
            val jsonResponse = gson.fromJson(responseBody, JsonObject::class.java)
            
            val data = jsonResponse.getAsJsonObject("data") ?: return emptyList()
            val securityVulnerabilities = data.getAsJsonObject("securityVulnerabilities") ?: return emptyList()
            val nodes = securityVulnerabilities.getAsJsonArray("nodes") ?: return emptyList()
            
            nodes.forEach { nodeElement ->
                val node = nodeElement.asJsonObject
                val advisory = node.getAsJsonObject("advisory") ?: return@forEach
                val versionRange = node.get("vulnerableVersionRange")?.asString ?: ""
                
                // Check if the component version is in the vulnerable range
                if (isVersionVulnerable(component.version, versionRange)) {
                    val vuln = parseGitHubVulnerability(advisory, component)
                    if (vuln != null) {
                        vulnerabilities.add(vuln)
                    }
                }
            }
        }
        
        return vulnerabilities
    }
    
    /**
     * Check if a version is vulnerable based on version range
     * Note: This is a simplified implementation. A production system would use
     * semantic versioning libraries to properly parse and compare version ranges.
     */
    private fun isVersionVulnerable(version: String?, versionRange: String): Boolean {
        // Simple check - if version range is empty or version is null, assume not vulnerable
        if (version == null || versionRange.isBlank()) {
            return false
        }
        
        // Basic pattern matching for common version range formats
        // Format: "< 1.10", ">= 1.0, < 2.0", etc.
        // For MVP, we use a conservative approach with basic pattern matching
        
        // If range contains the exact version, it's vulnerable
        if (versionRange.contains(version)) {
            return true
        }
        
        // Simple less-than check (e.g., "< 1.10")
        if (versionRange.startsWith("<") && !versionRange.startsWith("<=")) {
            val rangeVersion = versionRange.substring(1).trim()
            // Basic string comparison (works for simple versions)
            return version < rangeVersion
        }
        
        // Conservative: if we can't parse the range, report it
        // This prevents false negatives at the cost of potential false positives
        logger.debug("Unable to parse version range '$versionRange' for version '$version', reporting as potentially vulnerable")
        return true
    }
    
    /**
     * Parse GitHub Advisory into CycloneDX Vulnerability
     */
    private fun parseGitHubVulnerability(advisory: JsonObject, component: Component): Vulnerability? {
        try {
            val ghsaId = advisory.get("ghsaId")?.asString ?: return null
            val summary = advisory.get("summary")?.asString ?: ""
            val description = advisory.get("description")?.asString ?: summary
            val severity = advisory.get("severity")?.asString ?: "UNKNOWN"
            
            val cvss = advisory.getAsJsonObject("cvss")
            val cvssScore = cvss?.get("score")?.asDouble
            val cvssVector = cvss?.get("vectorString")?.asString
            
            val references = advisory.getAsJsonArray("references")
            val referenceUrl = if (references != null && references.size() > 0) {
                references.get(0).asJsonObject.get("url")?.asString
            } else {
                "https://github.com/advisories/$ghsaId"
            }
            
            val vulnerability = Vulnerability()
            vulnerability.id = ghsaId
            
            vulnerability.source = Vulnerability.Source().apply {
                name = "GitHub Security Advisory"
                url = referenceUrl
            }
            
            vulnerability.description = description
            
            // Set ratings
            if (cvssScore != null) {
                val rating = Vulnerability.Rating()
                rating.score = cvssScore
                rating.method = Vulnerability.Rating.Method.CVSSV31
                rating.vector = cvssVector
                
                // Map severity string to CycloneDX severity
                rating.severity = when (severity.uppercase()) {
                    "CRITICAL" -> Vulnerability.Rating.Severity.CRITICAL
                    "HIGH" -> Vulnerability.Rating.Severity.HIGH
                    "MODERATE", "MEDIUM" -> Vulnerability.Rating.Severity.MEDIUM
                    "LOW" -> Vulnerability.Rating.Severity.LOW
                    else -> Vulnerability.Rating.Severity.UNKNOWN
                }
                
                vulnerability.ratings = listOf(rating)
            }
            
            // Add affected component reference
            val affect = Vulnerability.Affect()
            affect.ref = component.bomRef
            vulnerability.affects = listOf(affect)
            
            return vulnerability
        } catch (e: Exception) {
            logger.warn("Failed to parse GitHub vulnerability: ${e.message}")
            return null
        }
    }
    
    /**
     * Parse OSS Index vulnerability data into CycloneDX format
     */
    private fun parseOssIndexVulnerability(vulnData: JsonObject, component: Component): Vulnerability? {
        try {
            val cveId = vulnData.get("cve")?.asString
            val title = vulnData.get("title")?.asString ?: ""
            val description = vulnData.get("description")?.asString ?: ""
            val cvssScore = vulnData.get("cvssScore")?.asDouble
            val cvssVector = vulnData.get("cvssVector")?.asString
            val reference = vulnData.get("reference")?.asString
            
            val vulnerability = Vulnerability()
            
            // Set ID (prefer CVE ID, fall back to stable hash)
            vulnerability.id = cveId ?: "OSSINDEX-${title.take(50).hashCode().toString(16).replace("-", "")}"
            
            // Set source
            vulnerability.source = Vulnerability.Source().apply {
                name = "OSS Index"
                url = reference
            }
            
            // Set description
            vulnerability.description = if (description.isNotBlank()) {
                description
            } else {
                title
            }
            
            // Set ratings with CVSS score
            if (cvssScore != null) {
                val rating = Vulnerability.Rating()
                rating.score = cvssScore
                rating.method = Vulnerability.Rating.Method.CVSSV3
                rating.vector = cvssVector
                
                // Map CVSS score to severity
                rating.severity = when {
                    cvssScore >= 9.0 -> Vulnerability.Rating.Severity.CRITICAL
                    cvssScore >= 7.0 -> Vulnerability.Rating.Severity.HIGH
                    cvssScore >= 4.0 -> Vulnerability.Rating.Severity.MEDIUM
                    cvssScore >= 0.1 -> Vulnerability.Rating.Severity.LOW
                    else -> Vulnerability.Rating.Severity.NONE
                }
                
                vulnerability.ratings = listOf(rating)
            }
            
            // Add affected component reference
            val affect = Vulnerability.Affect()
            affect.ref = component.bomRef
            vulnerability.affects = listOf(affect)
            
            return vulnerability
        } catch (e: Exception) {
            logger.warn("Failed to parse vulnerability: ${e.message}")
            return null
        }
    }
}
